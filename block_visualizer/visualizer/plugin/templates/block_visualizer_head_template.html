<style class="plugin-visualizer-head"></style>

<script class="plugin-visualizer-head">
    function renderBlockVisualizer(graph, width, height) {
        if (!width || !height) {
            let rect = document.getElementById('block-visualizer-main-div').getBoundingClientRect();
            width = width || rect.width;
            height = height || rect.height;
        }


        // The force simulation mutates links and nodes, so create a copy so that re-evaluating this cell produces the same result.
        const links = graph.edges.map(d => ({...d}));
        const nodes = graph.nodes.map(d => ({...d}));

        // Create a simulation with several forces.
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links)
                .id(d => d.id)
                .distance(250)
                .strength(0.5))
            .force("charge", d3.forceManyBody().strength(-30*120))
            .force("x", d3.forceX())
            .force("y", d3.forceY())
            .force("center", d3.forceCenter(0, 0))
            .force("collision", d3.forceCollide().radius(50));

        window.getGraphSimulation = () => simulation;


        // Create the SVG container.
        const svg = d3.select("#block-visualizer-main-div").append("svg")//;.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [-width / 2, -height / 2, width, height])
            .attr("style", "max-width: 100%; height: auto;");
        
        svg.append("defs")
            .append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 0)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
            .append("path")
                .attr("fill", "#999")
                .attr("d", "M0,-5L10,0L0,5")

        svg.select("#arrow").clone(true)
            .attr("id", "loop-arrow")
            .attr("refX", 0)
        
        // Use paths for links instead of lines
        const link = svg.append("g")
            .attr("fill", "none")
            .attr("stroke", "#000")
            .attr("stroke-opacity", 0.5)
            .attr("stroke-width", 3.2)
            .attr("zoom-and-pan", true)
            .selectAll("path")
            .data(links)
            .join("path")
            .attr("class", "link")
            .attr("source", d => d.source.id)
            .attr("destination", d => d.target.id)
            .attr("marker-mid", d =>
                !graph.directed
                    ? undefined
                    : (d.loop
                        ? "url(#loop-arrow)"
                        : "url(#arrow)"))
            .attr("mouse-over", true);

        const node = svg.append("g")
            .attr("zoom-and-pan", true)
            .selectAll("g")
            .data(nodes)
            .enter()
            .append("g")
            .attr("class", "node")
            .attr("id", d => d.id)
            .attr("drag", true)
            .attr("mouse-over", true);

        node.append("rect")
            .attr("class", "node-bounding-box")
            .attr("width", 1)
            .attr("height", 1)
            .attr("stroke", "#000")
            .attr("stroke-width", 1.5)
            .attr("fill", d => "#fff");

        node.append("text")
            .attr("class", "id-text")
            .attr("text-anchor", "start")
            .attr("y", "16px")
            .text(d => d.id);
        
        node.append("rect")
            .attr("class", "node-bounding-box-separator")
            .attr("width", 1)
            .attr("height", 1)
            .attr("y", "20px")
            .attr("stroke", "#000")
            .attr("stroke-width", 0.4)
            .attr("fill", d => "#000");
        
        node.append("text")
            .attr("class", "data-text-container")
            .attr("text-anchor", "start")
            .attr("y", "16px")
            .selectAll("tspan")
            .data(d => Object.entries(d.properties))
            .enter()
            .append("tspan")
            .attr("class", "data-text")
            .attr("x", "1px")
            .attr("dy", "20px")
            .text(d => `${d[0]}: ${d[1]}`);

        
        // Align node borders.
        const nodeBoundingBoxSeparators = document.getElementsByClassName("node-bounding-box-separator");
        for (const nodeBoundingBoxSeparator of nodeBoundingBoxSeparators) {
            const boundingBox = nodeBoundingBoxSeparator.parentNode.getBBox();
            
            nodeBoundingBoxSeparator.setAttribute("width", `${boundingBox.width + 1}px`);
        }
        const nodeBoundingBoxes = document.getElementsByClassName("node-bounding-box");
        for (const nodeBoundingBox of nodeBoundingBoxes) {
            const boundingBox = nodeBoundingBox.parentNode.getBBox();
            
            nodeBoundingBox.setAttribute("width", `${boundingBox.width}px`);
            nodeBoundingBox.setAttribute("height", `${boundingBox.height + 2}px`);
        }
        // Align node id.
        const nodeIdTexts = document.getElementsByClassName("id-text");
        for (const nodeIdText of nodeIdTexts) {
            const boundingBox = nodeIdText.parentNode.getBBox();
            
            nodeIdText.setAttribute("x", `${(boundingBox.width - nodeIdText.getBBox().width) / 2}px`);
        }

        // Set the position attributes of links and nodes each time the simulation ticks.
        simulation.on("tick", () => {
            link.attr("d", linkPath)
            node.attr("transform", d => `translate(${d.x}, ${d.y})`);
        });


        function linkPath(d) {
            const source = document.getElementById(d.source.id);
            const target = document.getElementById(d.target.id);

            if (source === null | target === null) return;

            const sx = d.source.x;
            const sy = d.source.y;
            const sw = source.getBBox().width;
            const sh = source.getBBox().height;
            const tx = d.target.x;
            const ty = d.target.y;
            const tw = target.getBBox().width;
            const th = target.getBBox().height;

            const elipseRadius = 1;
            const doubleEdgeSpacing = 10

            // Loop edge
            if (d.loop) {
                return `
                    M${sx + sw - 21.21},${sy + 21.21}
                    A${elipseRadius},${elipseRadius} 0 1,1 ${sx + sw + 21.21},${sy - 21.21}  
                    A${elipseRadius},${elipseRadius} 0 1,1 ${sx + sw - 21.21},${sy + 21.21}  
                `;
            }

            // Double edge
            if (graph.directed && d.double) {
                if (sx < tx && sy < ty) { // Source is above and to the left of the target.
                    return `M${sx + sw / 2 - doubleEdgeSpacing},${sy + sh / 2 + doubleEdgeSpacing}
                            L${(sx + sw / 2 - doubleEdgeSpacing + tx + tw / 2 - doubleEdgeSpacing) / 2},${(sy + sh / 2 + doubleEdgeSpacing + ty + th / 2 + doubleEdgeSpacing) / 2}
                            L${tx + tw / 2 - doubleEdgeSpacing},${ty + th / 2 + doubleEdgeSpacing}`;
                } else if (sx < tx && sy > ty) { // Source is below and to the left of the target.
                    return `M${sx + sw / 2 - doubleEdgeSpacing},${sy + sh / 2 - doubleEdgeSpacing}
                            L${(sx + sw / 2 - doubleEdgeSpacing + tx + tw / 2 - doubleEdgeSpacing) / 2},${(sy + sh / 2 - doubleEdgeSpacing + ty + th / 2 - doubleEdgeSpacing) / 2}
                            L${tx + tw / 2 - doubleEdgeSpacing},${ty + th / 2 - doubleEdgeSpacing}`;
                } else if (sx > tx && sy < ty) { // Source is above and to the right of the target.
                    return `M${sx + sw / 2 + doubleEdgeSpacing},${sy + sh / 2 + doubleEdgeSpacing}
                            L${(sx + sw / 2 + doubleEdgeSpacing + tx + tw / 2 + doubleEdgeSpacing) / 2},${(sy + sh / 2 + doubleEdgeSpacing + ty + th / 2 + doubleEdgeSpacing) / 2}
                            L${tx + tw / 2 + doubleEdgeSpacing},${ty + th / 2 + doubleEdgeSpacing}`;
                } else if (sx > tx && sy > ty) { // Source is below and to the right of the target.
                    return `M${sx + sw / 2 + doubleEdgeSpacing},${sy + sh / 2 - doubleEdgeSpacing}
                            L${(sx + sw / 2 + doubleEdgeSpacing + tx + tw / 2 + doubleEdgeSpacing) / 2},${(sy + sh / 2 - doubleEdgeSpacing + ty + th / 2 - doubleEdgeSpacing) / 2}
                            L${tx + tw / 2 + doubleEdgeSpacing},${ty + th / 2 - doubleEdgeSpacing}`;
                }

                return `M${sx + sw / 2},${sy + sh / 2} L${tx + tw / 2},${ty + th / 2}`;
            }

            // Normal edge
            return `M${sx + sw / 2},${sy + sh / 2}
                    L${(sx + sw / 2 + tx + tw / 2) / 2},${(sy + sh / 2 + ty + th / 2) / 2}
                    L${tx + tw / 2},${ty + th / 2}`;
        }
    }
    
    window.renderBlockVisualizer = renderBlockVisualizer;
</script>
