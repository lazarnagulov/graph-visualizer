<style class="plugin-visualizer-head"></style>

<script class="plugin-visualizer-head">
    function renderBlockVisualizer(graph, width, height) {
        if (!width || !height) {
            let rect = document.getElementById('block-visualizer-main-div').getBoundingClientRect();
            width = width || rect.width;
            height = height || rect.height;
        }

        rectWidth = 100;
        rectHeight = 60;

        // The force simulation mutates links and nodes, so create a copy so that re-evaluating this cell produces the same result.
        const links = graph.edges.map(d => ({...d}));
        const nodes = graph.nodes.map(d => ({...d}));

        // Create a simulation with several forces.
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links)
                .id(d => d.id)
                .distance(150)
                .strength(0.1))
            .force("charge", d3.forceManyBody().strength(-30*40*2))
            .force("x", d3.forceX())
            .force("y", d3.forceY())
            .force("center", d3.forceCenter(0, 0))
            .force("collision", d3.forceCollide().radius(50));

        window.getGraphSimulation = () => simulation;

        // Create the SVG container.
        const svg = d3.select("#block-visualizer-main-div").append("svg")//;.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [-width / 2, -height / 2, width, height])
            .attr("style", "max-width: 100%; height: auto;");
        
        svg.append("defs")
            .append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 0)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
            .append("path")
                .attr("fill", "#999")
                .attr("d", "M0,-5L10,0L0,5")

        svg.select("#arrow").clone(true)
            .attr("id", "loop-arrow")
            .attr("refX", 0)
        
        // Use paths for links instead of lines
        const link = svg.append("g")
            .attr("fill", "none")
            .attr("stroke", "#000")
            .attr("stroke-opacity", 0.5)
            .attr("stroke-width", 3.2)
            .selectAll("path")
            .data(links)
            .join("path")
            .attr("class", "link")
            .attr("source", d => d.source.id)
            .attr("destination", d => d.target.id)
            .attr("marker-mid", d =>
                !graph.directed
                    ? undefined
                    : (d.loop
                        ? "url(#loop-arrow)"
                        : "url(#arrow)")
            );

        const node = svg.append("g")
            .selectAll("g")
            .data(nodes)
            .enter()
            .append("g")
            .attr("class", "node")
            .attr("id", d => d.id)
            .attr("drag", true)

        node.append("rect")
            .attr("width", rectWidth)
            .attr("height", rectHeight)
            .attr("stroke", "#000")
            .attr("stroke-width", 1.5)
            .attr("fill", d => "#fff");

        node.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", ".35em")
            .attr("clip-path", "rect(0px 100px 60px 0px)")
            .text(d => d.id);

        // Set the position attributes of links and nodes each time the simulation ticks.
        simulation.on("tick", () => {
            link.attr("d", linkPath)
            node.attr("transform", d => `translate(${d.x}, ${d.y})`);
        });


        function linkPath(d) {
            const sx = d.source.x;
            const sy = d.source.y;
            const tx = d.target.x;
            const ty = d.target.y;

            const elipseRadius = 1;
            const doubleEdgeSpacing = 10

            // Loop edge
            if (d.loop) {
                return `
                    M${sx + rectWidth - rectHeight * 0.3535},${sy + rectHeight * 0.3535}
                    A${elipseRadius},${elipseRadius} 0 1,1 ${sx + rectWidth + rectHeight * 0.3535},${sy - rectHeight * 0.3535}  
                    A${elipseRadius},${elipseRadius} 0 1,1 ${sx + rectWidth - rectHeight * 0.3535},${sy + rectHeight * 0.3535}  
                `;
            }

            // Double edge
            if (graph.directed && d.double) {
                if (sx < tx && sy < ty) { // Source is above and to the left of the target.
                    return `M${sx + rectWidth / 2 - doubleEdgeSpacing},${sy + rectHeight / 2 + doubleEdgeSpacing}
                            L${(sx + tx + rectWidth - doubleEdgeSpacing * 2) / 2},${(sy + ty + rectHeight + doubleEdgeSpacing * 2) / 2}
                            L${tx + rectWidth / 2 - doubleEdgeSpacing},${ty + rectHeight / 2 + doubleEdgeSpacing}`;
                } else if (sx < tx && sy > ty) { // Source is below and to the left of the target.
                    return `M${sx + rectWidth / 2 - doubleEdgeSpacing},${sy + rectHeight / 2 - doubleEdgeSpacing}
                            L${(sx + tx + rectWidth - doubleEdgeSpacing * 2) / 2},${(sy + ty + rectHeight - doubleEdgeSpacing * 2) / 2}
                            L${tx + rectWidth / 2 - doubleEdgeSpacing},${ty + rectHeight / 2 - doubleEdgeSpacing}`;
                } else if (sx > tx && sy < ty) { // Source is above and to the right of the target.
                    return `M${sx + rectWidth / 2 + doubleEdgeSpacing},${sy + rectHeight / 2 + doubleEdgeSpacing}
                            L${(sx + tx + rectWidth + doubleEdgeSpacing * 2) / 2},${(sy + ty + rectHeight + doubleEdgeSpacing * 2) / 2}
                            L${tx + rectWidth / 2 + doubleEdgeSpacing},${ty + rectHeight / 2 + doubleEdgeSpacing}`;
                } else if (sx > tx && sy > ty) { // Source is below and to the right of the target.
                    return `M${sx + rectWidth / 2 + doubleEdgeSpacing},${sy + rectHeight / 2 - doubleEdgeSpacing}
                            L${(sx + tx + rectWidth + doubleEdgeSpacing * 2) / 2},${(sy + ty + rectHeight - doubleEdgeSpacing * 2) / 2}
                            L${tx + rectWidth / 2 + doubleEdgeSpacing},${ty + rectHeight / 2 - doubleEdgeSpacing}`;
                }

                return `M${sx + rectWidth / 2},${sy + rectHeight / 2} L${tx + rectWidth / 2},${ty + rectHeight / 2}`;
            }

            // Normal edge
            return `M${sx + rectWidth / 2},${sy + rectHeight / 2}
                    L${(sx + tx + rectWidth) / 2},${(sy + ty + rectHeight) / 2}
                    L${tx + rectWidth / 2},${ty + rectHeight / 2}`;
        }
    }
    
    window.renderBlockVisualizer = renderBlockVisualizer;
</script>
