<style>
    #data-display {
        height: auto;
        width: auto;
        min-height: 20px;
        min-width: 80px;
        padding: 3px;
        background-color: white;
        border: 2px solid black;
        position: fixed;
        z-index: 1;
        visibility: hidden;
        white-space: pre-wrap;
        text-align: center;
    }
</style>

<script>
    function swapHeadContent(event) {
        window.getGraphSimulation = undefined;
        if (event.detail.pathInfo.requestPath === "/change-visualizer")
        {
            const tempContainer = document.createElement("div");
            tempContainer.innerHTML = event.detail.serverResponse;

            d3.select(document.head).selectChildren(".plugin-visualizer-head").remove();
            d3.select(document.body).selectChildren(".plugin-visualizer-head").remove();
            d3.select(tempContainer)
                .selectAll(".plugin-visualizer-head")
                .each(function() {
                    let clonedNode = this.cloneNode(true)
                    if (clonedNode.nodeName === "SCRIPT") { // recreate script to force execution
                        const newScript = document.createElement("script");
                        for (const attr of clonedNode.attributes)
                            newScript.setAttribute(attr.name, attr.value);
                        if (!clonedNode.src)
                            newScript.textContent = clonedNode.textContent;

                        document.body.appendChild(newScript); // put at end of body for better coverage
                    }
                    else
                        document.head.appendChild(clonedNode); // other head tags

                    this.remove();
            });

            event.detail.serverResponse = tempContainer.innerHTML;
        }
    }
    function addMainViewFunctionality(event) {
        if (!window.getGraphSimulation) {
            console.log("ERROR: Graph simulation does not exist.");
            return;
        }

        const mainDivElements = document.querySelectorAll("[id$='visualizer-main-div']");
        if (mainDivElements.length != 1) {
            console.log("ERROR: There must be exactly one <[visualizer type]visualizer-main-div> element.");
            return;
        }

        let simulation = window.getGraphSimulation();

        // Drag functionality logic.
        d3.selectAll("g.node[drag='true']").call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));
        
        // Zoom and pan functionality logic.
        (function initZoom() {
            d3.select("svg").call(d3.zoom().on("zoom", e => d3.selectAll("g[zoom-and-pan='true']").attr("transform", e.transform)));
            // d3.zoom().on("zoom") recognizes the zoom event and applies the transformation it gets to the appropriate <g> elements.
        })();

        // "Mouse over" functionality logic.
        d3.selectAll("*[mouse-over='true']").attr("onmouseover", d => `mouseOver(${JSON.stringify(d)})`);
        d3.selectAll("*[mouse-over='true']").attr("onmouseout", d => `mouseOut()`)

        const dataDisplay = document.createElement("div");
        dataDisplay.id = "data-display";
        mainDivElements[0].appendChild(dataDisplay);

        // Reheat the simulation when drag starts, and fix the subject position.
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        // Update the subject (dragged node) position during drag.
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        // Restore the target alpha so the simulation cools after dragging ends.
        // Unfix the subject position now that itâ€™s no longer being dragged.
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }

        function mouseOver(element) {
            const properties = element.properties;
            let dataDisplay = document.getElementById("data-display")

            let text = "";
            if ("id" in element) { // Element is a node.
                for (const key in properties) {
                    if (Object.keys(properties).length == 2 && "type" in properties && "value" in properties) {
                        text += `${properties["value"]}\n`; // Beautifing output in case of a List literal.
                        break;
                    } else {
                        text += `${key}: ${properties[key]}\n`;
                    }
                }
                let nodeBouds = document.getElementById(element.id).getBoundingClientRect();
                
                dataDisplay.style.left = `${nodeBouds.left + nodeBouds.width / 2 + 70}px`;
                dataDisplay.style.top = `${nodeBouds.top}px`;

            } else { // Element is a link.
                for (const key in properties) {
                    if (Object.keys(properties).length == 1 && typeof(properties[key]) === "boolean") {
                        text += `${key}\n`; // Beautifing output in case of a link with no additional properties.
                        break;
                    } else {
                        text += `${key}: ${properties[key]}\n`;
                    }
                }
                let sourceNodeBounds = document.getElementById(element.source.id).getBoundingClientRect();
                let targetNodeBounds = document.getElementById(element.target.id).getBoundingClientRect();
                let sourceNodeMiddlePoint = [sourceNodeBounds.left + sourceNodeBounds.width / 2, sourceNodeBounds.top + sourceNodeBounds.height / 2];
                let targetNodeMiddlePoint = [targetNodeBounds.left + targetNodeBounds.width / 2, targetNodeBounds.top + targetNodeBounds.height / 2];

                dataDisplay.style.left = `${(sourceNodeMiddlePoint[0] + targetNodeMiddlePoint[0]) / 2}px`;
                dataDisplay.style.top = `${(sourceNodeMiddlePoint[1] + targetNodeMiddlePoint[1]) / 2}px`;
            }

            dataDisplay.textContent = text;
            dataDisplay.style.visibility = "visible";
        }
        window.mouseOver = mouseOver;

        function mouseOut() {
            var dataDisplay = document.getElementById("data-display")
            dataDisplay.style.visibility = "hidden";
        }
        window.mouseOut = mouseOut;
    }
</script>