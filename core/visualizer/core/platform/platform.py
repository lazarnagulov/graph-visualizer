from typing import List, Optional

from visualizer.core.platform.workspace import Workspace
from visualizer.core.service.plugin_service import PluginService


class Platform:

    def __init__(self, plugin_service: Optional[PluginService] = None):
        """
        Initialize a Platform instance with the given plugin service.

        A new workspace is created during initialization and set as the current workspace.

        :param plugin_service: The plugin service used by workspaces.
        :type plugin_service: Optional[PluginService]
        """
        self.plugin_service = plugin_service if plugin_service else PluginService()
        self.workspaces: dict[str, Workspace] = {}
        self.current_workspace_id: str = ""
        self.create_workspace()


    def create_workspace(self) -> Workspace:
        """
        Create a new workspace and set it as the current workspace.

        A new Workspace instance is created using the associated plugin service.
        The workspace is registered and becomes the active one.

        :return: The newly created workspace.
        :rtype: Workspace
        """
        ws = Workspace(self.plugin_service)
        self.workspaces[ws.id] = ws
        self.current_workspace_id = ws.id
        return ws
    

    def delete_workspace(self, workspace_id: str) -> bool:
        """
        Delete an existing workspace by ID.

        If the workspace exists, it is removed and the current workspace is updated.
        If any workspaces remain, the next one is selected as current. If none remain,
        the current workspace is set to None.

        If the new current workspace has data, it will automatically regenerate its graph.

        :param workspace_id: ID of the workspace to delete.
        :type workspace_id: str

        :return: True if deletion was successful, False if the workspace was not found.
        :rtype: bool
        """
        if workspace_id not in self.workspaces:
            return False

        ids = list(self.workspaces.keys())
        idx = ids.index(workspace_id)
        del self.workspaces[workspace_id]

        remaining_ids = list(self.workspaces.keys())
        if remaining_ids:
            if idx < len(remaining_ids):
                self.current_workspace_id = remaining_ids[idx]
            else:
                self.current_workspace_id = remaining_ids[-1]
        else:
            self.current_workspace_id = None

        if self.current_workspace_id:
            current_ws = self.workspaces[self.current_workspace_id]
            if current_ws.data_file_string:
                current_ws.generate_graph()

        return True


    def get_selected_workspace(self) -> Workspace:
        """
        Get the currently selected workspace.

        If no workspace is currently selected, a new one is created and returned.

        :return: The currently selected workspace.
        :rtype: Workspace
        """
        if self.current_workspace_id:
            return self.workspaces[self.current_workspace_id]
        return self.create_workspace()


    def switch_workspace(self, workspace_id: str) -> bool:
        """
        Switch the current workspace to the one with the given ID.

        The workspace is set as the active one. If it contains data,
        it may be regenerated by the caller as needed.

        :param workspace_id: ID of the workspace to switch to.
        :type workspace_id: str

        :return: True if the workspace exists and switching succeeded, False otherwise.
        :rtype: bool
        """
        if workspace_id in self.workspaces:
            self.current_workspace_id = workspace_id
            return True
        return False


    def switch_workspace_by_offset(self, offset: int) -> bool:
        """
        Switch to a workspace based on an offset relative to the current one.

        Useful for navigating forward or backward in the list of workspaces.

        :param offset: The number of positions to move (positive or negative).
        :type offset: int

        :return: True if the switch was successful, False otherwise.
        :rtype: bool
        """
        ids = list(self.workspaces.keys())
        if self.current_workspace_id and ids:
            try:
                idx = ids.index(self.current_workspace_id)
            except ValueError:
                return False

            new_idx = max(0, min(len(ids) - 1, idx + offset))
            return self.switch_workspace(ids[new_idx])
        return False


    def switch_to_next_workspace(self) -> bool:
        """
        Switch to the next workspace in the list.

        :return: True if the switch was successful, False otherwise.
        :rtype: bool
        """
        return self.switch_workspace_by_offset(1)


    def switch_to_previous_workspace(self) -> bool:
        """
        Switch to the previous workspace in the list.

        :return: True if the switch was successful, False otherwise.
        :rtype: bool
        """
        return self.switch_workspace_by_offset(-1)


    def list_workspaces(self) -> List[Workspace]:
        """
        Get a list of all registered workspaces.

        :return: A list of all workspaces.
        :rtype: List[Workspace]
        """
        return list(self.workspaces.values())
