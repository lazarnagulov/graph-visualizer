<style class="plugin-visualizer-head">
    #data-display {
        height: auto;
        width: auto;
        min-height: 20px;
        min-width: 80px;
        padding: 3px;
        background-color: white;
        border: 2px solid black;
        position: fixed;
        z-index: 1;
        visibility: hidden;
        white-space: pre-wrap;
        text-align: center;
    }
</style>

<script class="plugin-visualizer-head">
    function mouseOver(element) {
        const properties = element.properties;
        let dataDisplay = document.getElementById("data-display")

        let text = "";
        if ("id" in element) { // Element is a node.
            for (const key in properties) {
                if (Object.keys(properties).length == 2 && "type" in properties && "value" in properties) {
                    text += `${properties["value"]}\n`; // Beautifing output in case of a List literal.
                    break;
                } else {
                    text += `${key}: ${properties[key]}\n`;
                }
            }
            let nodeBouds = document.getElementById(element.id).getBoundingClientRect();
            
            dataDisplay.style.left = `${nodeBouds.left + nodeBouds.width / 2 + 70}px`;
            dataDisplay.style.top = `${nodeBouds.top}px`;

        } else { // Element is a link.
            for (const key in properties) {
                if (Object.keys(properties).length == 1 && typeof(properties[key]) === "boolean") {
                    text += `${key}\n`; // Beautifing output in case of a link with no additional properties.
                    break;
                } else {
                    text += `${key}: ${properties[key]}\n`;
                }
            }
            let sourceNodeBounds = document.getElementById(element.source.id).getBoundingClientRect();
            let targetNodeBounds = document.getElementById(element.target.id).getBoundingClientRect();
            let sourceNodeMiddlePoint = [sourceNodeBounds.left + sourceNodeBounds.width / 2, sourceNodeBounds.top + sourceNodeBounds.height / 2];
            let targetNodeMiddlePoint = [targetNodeBounds.left + targetNodeBounds.width / 2, targetNodeBounds.top + targetNodeBounds.height / 2];

            dataDisplay.style.left = `${(sourceNodeMiddlePoint[0] + targetNodeMiddlePoint[0]) / 2}px`;
            dataDisplay.style.top = `${(sourceNodeMiddlePoint[1] + targetNodeMiddlePoint[1]) / 2}px`;
        }

        dataDisplay.textContent = text;
        dataDisplay.style.visibility = "visible";
    }

    function mouseOut() {
        var dataDisplay = document.getElementById("data-display")
        dataDisplay.style.visibility = "hidden";
    }

    function renderSimpleVisualizer(graph, width, height) {
        if (!width || !height) {
            let rect = document.getElementById('simple-visualizer-main-div').getBoundingClientRect();
            width = width || rect.width;
            height = height || rect.height;
        }

        // The force simulation mutates links and nodes, so create a copy
        // so that re-evaluating this cell produces the same result.
        const links = graph.edges.map(d => ({...d}));
        const nodes = graph.nodes.map(d => ({...d}));

        // Create a simulation with several forces.
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links)
                .id(d => d.id)
                .distance(150)
                .strength(0.1))
            .force("charge", d3.forceManyBody().strength(-30*40*2))
            .force("x", d3.forceX())
            .force("y", d3.forceY())
            .force("center", d3.forceCenter(0, 0))
            .force("collision", d3.forceCollide().radius(50));

        window.getGraphSimulation = () => simulation;

        // Create the SVG container.
        const svg = d3.select("#simple-visualizer-main-div").append("svg")//;.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [-width / 2, -height / 2, width, height])
            .attr("style", "max-width: 100%; height: auto;");

        svg.append("defs")
            .append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 30) // node radius (40) + arrow padding
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
            .append("path")
                .attr("fill", "#999")
                .attr("d", "M0,-5L10,0L0,5")

        svg.select("#arrow").clone(true)
            .attr("id", "loop-arrow")
            .attr("refX", 9)
            // Use paths for links instead of lines

        const link = svg.append("g")
            .attr("fill", "none")
            .attr("stroke", "#000")
            .attr("stroke-opacity", 0.5)
            .attr("stroke-width", 3.2)
            .selectAll("path")
            .data(links)
            .join("path")
            .attr("class", "link")
            .attr("source", d => d.source.id)
            .attr("destination", d => d.target.id)
            .attr("marker-end", d =>
                !graph.directed
                    ? undefined
                    : (d.loop
                        ? "url(#loop-arrow)"
                        : "url(#arrow)"))
            .attr("onmouseover", d => `mouseOver(${JSON.stringify(d)})`)
            .attr("onmouseout", d => `mouseOut()`);

        const node = svg.append("g")
            .selectAll("g")
            .data(nodes)
            .enter()
            .append("g")
            .attr("class", "node")
            .attr("id", d => d.id)
            .attr("drag", true)

        node.append("circle")
            .attr("stroke", "#000")
            .attr("stroke-width", 1.5)
            .attr("r", 40)
            .attr("fill", d => "#fff");

        node.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", ".35em")
            .attr("clip-path", "circle(40)")
            .attr("onmouseover", d => `mouseOver(${JSON.stringify(d)})`)
            .attr("onmouseout", d => `mouseOut()`)
            .text(d => d.id);
        
        const dataDisplay = document.createElement("div");
        dataDisplay.id = "data-display";
        document.getElementById("simple-visualizer-main-div").appendChild(dataDisplay);

        // Zoom and pan functionality logic.
        (function initZoom() {
            svg.call(d3.zoom().on("zoom", e => d3.selectAll('svg > g').attr('transform', e.transform)));

            // Selects all <g> tags which have <svg> tag as the parent.
            // There are two. The first one holds the link data, and the second one the node data.
            // d3.zoom().on("zoom") recognizes the zoom event and applies the transformation it gets from the cursor to the <g> tags.
        })();

        // Set the position attributes of links and nodes each time the simulation ticks.
        simulation.on("tick", () => {
            link.attr("d", linkPath)
            node.attr("transform", d => `translate(${d.x}, ${d.y})`);
        });

        function linkPath(d) {
            if (d.loop) { // loop edge
                const nodeR = 40;
                const loopR = 50;
                const startAngle = -Math.PI / 2;
                const endAngle = startAngle + 2.5;

                const sx = d.source.x + nodeR * Math.cos(startAngle);
                const sy = d.source.y + nodeR * Math.sin(startAngle);
                const tx = d.source.x + nodeR * Math.cos(endAngle);
                const ty = d.source.y + nodeR * Math.sin(endAngle);

                return `
                    M${sx},${sy}
                    A${loopR},${loopR} 0 1,1 ${tx},${ty}
                `;
            }

            if (graph.directed && d.double) { // double edge
                let offset = Victor(d.target.x - d.source.x, d.target.y - d.source.y)
                    .normalize()
                    .rotateDeg(90)
                    .multiplyScalar(10);
                return `M${d.source.x+offset.x},${d.source.y+offset.y}
                        L${d.target.x+offset.x},${d.target.y+offset.y}`;
            }

            return `M${d.source.x},${d.source.y} L${d.target.x},${d.target.y}`; // normal edge
        }
    }
    window.renderSimpleVisualizer = renderSimpleVisualizer;
</script>
